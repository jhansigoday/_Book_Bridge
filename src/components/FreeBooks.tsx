
import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { BookOpen, User, Maximize, Library } from 'lucide-react';
import { booksData } from '@/data/booksData';
import { BookReader } from '@/components/BookReader';

interface Book {
  id: string;
  title: string;
  author: string;
  category: string;
  description: string;
  isfeatured: boolean;
  is_free_to_read: boolean;
  content?: { page: number; text: string }[];
}

const additionalFreeBooks: Book[] = [
 [
  {
    id: 'free-4',
    title: 'The Art of Programming',
    author: 'Sarah Chen',
    category: 'Technology',
    description: 'A comprehensive guide to programming principles and best practices. Learn the fundamentals that every developer should know.',
    isfeatured: true,
    is_free_to_read: true,
    content: [
      { page: 1, text: 'Chapter 1: Introduction to Programming\n\nProgramming is both an art and a science. It requires logical thinking, creativity, and attention to detail. In this book, we will explore the fundamental concepts that make great programmers.\n\nThe journey of learning to program is like learning a new language. At first, the syntax may seem foreign and the concepts abstract. However, with practice and patience, you will begin to see patterns and develop an intuitive understanding of how computers think.\n\nProgramming is not just about writing code; it\'s about solving problems. Every program you write should address a specific need or challenge. The best programmers are those who can break down complex problems into smaller, manageable pieces and then implement elegant solutions.\n\nIn the modern world, programming skills are becoming increasingly valuable across all industries. From healthcare to finance, from entertainment to education, software is transforming how we work and live.' },
      { page: 2, text: 'The first principle of good programming is clarity. Your code should tell a story that other developers can easily understand and follow. This means using meaningful variable names, writing clear comments, and organizing your code in a logical structure.\n\nConsider the following example:\n\n// Poor naming\nint x = 5;\nint y = 10;\nint z = x * y;\n\n// Clear naming\nint length = 5;\nint width = 10;\nint area = length * width;\n\nThe second example immediately tells us what the code is doing - calculating the area of a rectangle. Good code is self-documenting and requires minimal explanation.\n\nAnother important aspect of clarity is consistency. Choose a coding style and stick to it throughout your project. This includes consistent indentation, naming conventions, and code organization.' },
      { page: 3, text: 'Programming languages are tools, and like any craftsperson, you should choose the right tool for the job. Different languages excel in different domains. Python is excellent for data science and rapid prototyping, JavaScript dominates web development, C++ is preferred for system programming and games, while R is specialized for statistical analysis.\n\nDon\'t fall into the trap of language fanaticism. A good programmer can adapt to different languages and paradigms. The fundamental concepts of programming - variables, functions, loops, conditionals - remain consistent across languages, even if the syntax varies.\n\nLearning your first programming language is the hardest. You\'re not just learning syntax; you\'re learning to think computationally. Once you master one language, picking up additional languages becomes much easier because you already understand the underlying concepts.\n\nThe key is to start with a beginner-friendly language like Python or JavaScript, build solid fundamentals, and then expand your toolkit as needed.' },
      { page: 4, text: 'Problem-solving is the heart of programming. Before you write a single line of code, you should thoroughly understand the problem you\'re trying to solve. This involves asking the right questions: What exactly needs to be accomplished? What are the inputs and expected outputs? What are the constraints and edge cases?\n\nOne effective approach is to work backwards from the desired outcome. Start by clearly defining what success looks like, then identify the steps needed to achieve that outcome. Break complex problems into smaller subproblems that you can solve independently.\n\nPseudocode is a valuable tool for planning your solution. Write out your algorithm in plain English before translating it into code. This helps you organize your thoughts and identify potential issues before you start programming.\n\nFor example, if you\'re writing a program to find the largest number in a list:\n1. Start with the first number as the current maximum\n2. Compare each subsequent number to the current maximum\n3. If a number is larger, make it the new maximum\n4. Return the maximum after checking all numbers' },
      { page: 5, text: 'Debugging is an essential skill that every programmer must master. Bugs are inevitable - even experienced programmers write buggy code. The difference is that experienced programmers know how to find and fix bugs efficiently.\n\nThe first step in debugging is to reproduce the problem consistently. If you can\'t reliably reproduce a bug, you can\'t verify that you\'ve fixed it. Take detailed notes about the conditions that trigger the bug.\n\nUse debugging tools provided by your development environment. Modern IDEs offer powerful debuggers that let you step through your code line by line, inspect variable values, and set breakpoints. Learn to use these tools effectively.\n\nPrint statements (or logging) are simple but effective debugging techniques. Strategically placed print statements can help you trace the flow of your program and identify where things go wrong.\n\nThe rubber duck debugging technique involves explaining your code line by line to an inanimate object (like a rubber duck). Often, the act of verbalizing your logic helps you spot the error.' },
      { page: 6, text: 'Chapter 2: Data Structures\n\nData structures are the building blocks of efficient algorithms. Understanding how to organize and manipulate data is crucial for any programmer. Different data structures are optimized for different types of operations.\n\nArrays are the most basic data structure. They store elements in contiguous memory locations, allowing for fast random access. However, inserting or deleting elements in the middle of an array can be expensive because all subsequent elements must be shifted.\n\nLinked lists solve the insertion and deletion problem by using pointers to connect elements. Each element (or node) contains data and a reference to the next element. This makes insertion and deletion at any position very efficient, but random access becomes slower.\n\nStacks follow the Last-In-First-Out (LIFO) principle. Think of a stack of plates - you can only add or remove plates from the top. Stacks are essential for function calls, expression evaluation, and backtracking algorithms.' },
      { page: 7, text: 'Queues implement the First-In-First-Out (FIFO) principle, like a line at a coffee shop. The first person in line is the first to be served. Queues are fundamental in breadth-first search algorithms, task scheduling, and handling requests in web servers.\n\nTrees are hierarchical data structures with a root node and child nodes. Binary search trees maintain a specific ordering that allows for efficient searching, insertion, and deletion operations. The average time complexity for these operations is O(log n).\n\nHash tables (or hash maps) provide near-constant time complexity for insertion, deletion, and lookup operations. They use a hash function to map keys to array indices, making them incredibly efficient for key-value storage.\n\nGraphs represent relationships between entities. They consist of vertices (nodes) and edges (connections). Graphs can model social networks, transportation systems, and many other real-world scenarios.' },
      { page: 8, text: 'Understanding when to use each data structure is crucial for writing efficient programs. Arrays are perfect when you need fast random access and the size of your data is relatively fixed. Use linked lists when you need frequent insertions and deletions at arbitrary positions.\n\nChoose stacks when you need to reverse the order of items or implement recursive algorithms iteratively. Queues are ideal for scheduling tasks, handling requests, or implementing breadth-first traversals.\n\nHash tables are your go-to choice for fast lookups, especially when dealing with large datasets. They\'re perfect for implementing caches, databases, and associating keys with values.\n\nTrees are excellent for hierarchical data like file systems, organizational charts, or decision trees. Binary search trees provide efficient searching in sorted data.\n\nGraphs are essential for modeling networks, social connections, or any scenario where entities have relationships with each other. They\'re fundamental in GPS navigation, social media recommendations, and network analysis.' },
      { page: 9, text: 'Dynamic arrays (like Python lists or JavaScript arrays) combine the benefits of arrays and linked lists. They provide fast random access like arrays but can grow and shrink dynamically like linked lists. They achieve this by allocating extra space and periodically resizing when needed.\n\nSets are collections that contain only unique elements. They\'re useful for removing duplicates, testing membership, and performing set operations like union and intersection. Most programming languages provide efficient set implementations.\n\nMultidimensional arrays allow you to represent matrices, tables, or grid-like data structures. They\'re essential for image processing, scientific computing, and game development where you need to work with 2D or 3D data.\n\nDeques (double-ended queues) allow insertion and deletion at both ends. They combine the benefits of stacks and queues and are useful when you need flexible access to both ends of your data.' },
      { page: 10, text: 'Memory management is closely tied to data structure choice. Arrays typically use contiguous memory, which provides better cache performance but can lead to memory fragmentation. Linked structures use scattered memory locations, which can reduce cache efficiency but provide more flexible memory usage.\n\nUnderstanding the memory layout of your data structures helps you write more efficient programs. Consider how your data will be accessed and choose structures that align with those access patterns.\n\nCache-friendly programming involves organizing your data and algorithms to take advantage of CPU caches. Sequential access patterns are generally faster than random access patterns because they make better use of cache prefetching.\n\nIn languages without garbage collection, you must manually manage memory allocation and deallocation. Always free allocated memory to prevent memory leaks, and be careful not to access freed memory.' },
      { page: 11, text: 'Chapter 3: Algorithms\n\nAn algorithm is a step-by-step procedure for solving a problem. Good algorithms are efficient, correct, and elegant. Understanding algorithm complexity helps you choose the right approach for your specific problem.\n\nTime complexity measures how the running time of an algorithm changes as the input size grows. Common time complexities include:\n\n• O(1) - Constant time: The algorithm takes the same amount of time regardless of input size\n• O(log n) - Logarithmic time: Time increases slowly as input size grows\n• O(n) - Linear time: Time increases proportionally with input size\n• O(n²) - Quadratic time: Time increases with the square of input size\n\nSorting algorithms demonstrate these concepts well. Bubble sort has O(n²) time complexity, while merge sort achieves O(n log n). For large datasets, this difference can mean the difference between seconds and hours of computation time.\n\nThe key to mastering algorithms is understanding when to apply each one and recognizing the trade-offs between time and space complexity.' },
      { page: 12, text: 'Searching algorithms are fundamental to computer science. Linear search examines each element sequentially until it finds the target, resulting in O(n) time complexity. Binary search, which only works on sorted data, can find elements in O(log n) time by repeatedly dividing the search space in half.\n\nBinary search demonstrates the power of divide-and-conquer algorithms. By eliminating half of the remaining possibilities with each comparison, it dramatically reduces the number of operations needed.\n\nHashing provides another approach to searching, offering average-case O(1) lookup time. Hash-based searching trades some worst-case guarantees for exceptional average performance.\n\nInterpolation search can outperform binary search on uniformly distributed data by making educated guesses about where the target might be located, similar to how you might search for a word in a dictionary.' },
      { page: 13, text: 'Sorting algorithms showcase different algorithmic paradigms. Bubble sort and selection sort are simple but inefficient O(n²) algorithms that work by repeatedly finding and placing elements in their correct positions.\n\nMerge sort exemplifies the divide-and-conquer approach. It recursively divides the array into smaller subarrays, sorts them, and then merges them back together. This consistent O(n log n) performance makes it reliable for large datasets.\n\nQuicksort is another divide-and-conquer algorithm that\'s often faster in practice. It selects a pivot element and partitions the array around it, then recursively sorts the partitions. While its worst-case performance is O(n²), it averages O(n log n) and has good cache performance.\n\nHeapsort uses a heap data structure to achieve O(n log n) performance with O(1) space complexity. It\'s useful when memory usage is a concern.' },
      { page: 14, text: 'Dynamic programming is a powerful technique for solving optimization problems. It works by breaking problems into smaller subproblems and storing the results to avoid redundant calculations. The key insight is that many problems have overlapping subproblems that can be solved once and reused.\n\nThe classic example is computing Fibonacci numbers. A naive recursive approach recalculates the same values repeatedly, leading to exponential time complexity. Dynamic programming stores previously computed values, reducing the complexity to linear time.\n\nTwo main approaches exist: top-down (memoization) and bottom-up (tabulation). Memoization caches results as needed during recursive calls, while tabulation builds up solutions systematically from the smallest subproblems.\n\nDynamic programming is essential for solving problems like finding the longest common subsequence, optimizing resource allocation, and many graph algorithms.' },
      { page: 15, text: 'Greedy algorithms make locally optimal choices at each step, hoping to find a globally optimal solution. They\'re often simpler than dynamic programming but don\'t always guarantee optimal results.\n\nThe activity selection problem demonstrates greedy algorithms well. Given a set of activities with start and end times, you want to select the maximum number of non-overlapping activities. The greedy approach of always selecting the activity that ends earliest produces an optimal solution.\n\nDijkstra\'s algorithm for finding shortest paths in graphs is another successful greedy algorithm. It always processes the unvisited vertex with the smallest known distance, gradually building up the shortest path tree.\n\nHowever, greedy algorithms don\'t always work. The coin change problem shows this - while making change with the fewest coins often works with standard denominations, it can fail with arbitrary coin systems.' },
      { page: 16, text: 'Graph algorithms solve problems involving networks of connected nodes. Depth-first search (DFS) explores as far as possible along each branch before backtracking. It\'s useful for detecting cycles, topological sorting, and finding connected components.\n\nBreadth-first search (BFS) explores all neighbors at the current depth before moving to the next level. It\'s perfect for finding shortest paths in unweighted graphs and level-order traversals.\n\nDijkstra\'s algorithm finds shortest paths in weighted graphs with non-negative edge weights. It maintains a priority queue of vertices ordered by their tentative distances and systematically explores the closest unvisited vertices.\n\nThe Floyd-Warshall algorithm finds shortest paths between all pairs of vertices using dynamic programming. While it has O(n³) time complexity, it\'s simpler to implement than running Dijkstra\'s algorithm from each vertex.' },
      { page: 17, text: 'Chapter 4: Object-Oriented Programming\n\nObject-oriented programming (OOP) is a paradigm that organizes code around objects - entities that contain both data (attributes) and code (methods). This approach models real-world entities and their interactions, making complex programs easier to understand and maintain.\n\nThe four pillars of OOP are encapsulation, inheritance, polymorphism, and abstraction. These principles work together to create flexible, reusable, and maintainable code.\n\nEncapsulation bundles data and methods that operate on that data within a single unit (the object). It also restricts direct access to some components, preventing accidental modification of internal state. This is achieved through access modifiers like private, protected, and public.\n\nClasses serve as blueprints for creating objects. They define the structure and behavior that objects of that type will have. For example, a Car class might have attributes like color, model, and speed, along with methods like start(), stop(), and accelerate().' },
      { page: 18, text: 'Inheritance allows classes to inherit properties and methods from parent classes, promoting code reuse and establishing hierarchical relationships. A Vehicle parent class might define common attributes like speed and fuel, while Car and Motorcycle child classes add their specific features.\n\nPolymorphism enables objects of different classes to be treated uniformly through a common interface. The same method name can behave differently depending on the object type. For example, both Dog and Cat classes might have a makeSound() method, but they produce different sounds.\n\nAbstraction hides complex implementation details while exposing only the necessary interface. Users of a class don\'t need to understand its internal workings - they just need to know how to use its public methods.\n\nThese principles together create a powerful programming model that mirrors how we naturally think about the world - in terms of objects and their relationships.' },
      { page: 19, text: 'Design patterns are reusable solutions to common programming problems. They provide templates for how to solve problems that occur repeatedly in software design. Understanding design patterns improves your ability to design flexible and maintainable systems.\n\nThe Singleton pattern ensures that a class has only one instance and provides global access to that instance. It\'s useful for resources like database connections or logging systems where you want to avoid creating multiple instances.\n\nThe Observer pattern defines a one-to-many dependency between objects. When one object changes state, all dependent objects are notified automatically. This pattern is fundamental to event-driven programming and model-view architectures.\n\nThe Strategy pattern encapsulates algorithms and makes them interchangeable. It allows you to define a family of algorithms, encapsulate each one, and make them interchangeable at runtime. This is useful when you have multiple ways to perform a task.' },
      { page: 20, text: 'The Factory pattern creates objects without specifying their exact classes. It provides an interface for creating objects, but lets subclasses decide which classes to instantiate. This promotes loose coupling by eliminating the need to bind application-specific classes into code.\n\nThe Decorator pattern adds new functionality to objects dynamically without altering their structure. It provides a flexible alternative to subclassing for extending functionality. For example, you might decorate a basic Coffee object with Milk, Sugar, or WhippedCream decorators.\n\nThe Model-View-Controller (MVC) pattern separates an application into three interconnected components. The Model manages data and business logic, the View handles the user interface, and the Controller manages user input and coordinates between Model and View. This separation makes applications easier to maintain and test.' },
      { page: 21, text: 'Chapter 5: Software Engineering Practices\n\nSoftware engineering extends beyond coding to encompass the entire process of building software systems. It includes planning, design, implementation, testing, deployment, and maintenance. Good software engineering practices ensure that projects are completed on time, within budget, and meet user requirements.\n\nVersion control systems like Git are essential tools for managing code changes over time. They allow multiple developers to work on the same project simultaneously, track the history of changes, and merge different versions of code. Understanding Git workflows like feature branches and pull requests is crucial for collaborative development.\n\nCode reviews are a quality assurance practice where other developers examine your code before it\'s merged into the main codebase. Reviews catch bugs, ensure code quality, and share knowledge among team members. They\'re one of the most effective ways to improve code quality and team skills.\n\nTesting is integral to software development. Unit tests verify that individual components work correctly, integration tests ensure that components work together, and end-to-end tests validate entire user workflows.' },
      { page: 22, text: 'Test-driven development (TDD) is a practice where you write tests before writing the actual code. The cycle is: write a failing test, write the minimum code to make it pass, then refactor. This approach leads to better-designed, more reliable code and comprehensive test coverage.\n\nContinuous integration (CI) automatically builds and tests code changes as they\'re committed to version control. This catches integration problems early and ensures that the main codebase always builds successfully. CI tools like Jenkins, GitHub Actions, or GitLab CI can run tests, check code quality, and deploy applications automatically.\n\nCode documentation is often overlooked but crucial for maintainability. Good documentation includes comments explaining complex logic, API documentation describing how to use your code, and architectural documentation explaining system design decisions.\n\nRefactoring is the process of improving code structure without changing its external behavior. Regular refactoring keeps code clean, readable, and maintainable. Common refactoring techniques include extracting methods, renaming variables, and eliminating code duplication.' },
      { page: 23, text: 'Agile methodologies like Scrum and Kanban provide frameworks for managing software development projects. They emphasize iterative development, customer collaboration, and responding to change over following rigid plans.\n\nScrum organizes work into short sprints (usually 2-4 weeks) with defined goals. Teams hold daily standup meetings, sprint planning sessions, and retrospectives to continuously improve their process. The Product Owner prioritizes features, while the Scrum Master facilitates the process.\n\nKanban visualizes work as it flows through different stages (To Do, In Progress, Done). It limits work in progress to prevent bottlenecks and emphasizes continuous delivery rather than fixed-length iterations.\n\nBoth approaches value working software over comprehensive documentation, customer collaboration over contract negotiation, and individuals and interactions over processes and tools.' },
      { page: 24, text: 'Code quality metrics help assess the maintainability and reliability of software. Cyclomatic complexity measures the number of independent paths through code - lower complexity generally means easier-to-understand and test code.\n\nCode coverage indicates what percentage of your code is executed by tests. While high coverage doesn\'t guarantee good tests, very low coverage often indicates insufficient testing.\n\nTechnical debt refers to the cost of choosing quick solutions over better approaches. Like financial debt, technical debt accumulates interest over time, making future changes more difficult and expensive. Regular refactoring helps manage technical debt.\n\nCode smells are indicators of deeper problems in code structure. Examples include long methods, large classes, duplicate code, and complex conditional logic. Recognizing and addressing code smells improves code quality and maintainability.' },
      { page: 25, text: 'Chapter 6: Modern Development Tools\n\nIntegrated Development Environments (IDEs) provide comprehensive tools for software development. Modern IDEs like Visual Studio Code, IntelliJ IDEA, and Eclipse offer features like syntax highlighting, auto-completion, debugging, and integrated version control.\n\nPackage managers like npm (Node.js), pip (Python), and Maven (Java) simplify dependency management. They handle downloading, installing, and updating external libraries your project depends on, ensuring consistent environments across different machines.\n\nBuild tools automate the process of compiling, testing, and packaging applications. Tools like Webpack, Gradle, and Make define build pipelines that can be executed consistently across different environments.\n\nContainerization with Docker allows you to package applications with their dependencies into portable containers. This ensures that applications run consistently across different environments, from development laptops to production servers.' },
      { page: 26, text: 'Cloud platforms like AWS, Google Cloud, and Azure provide scalable infrastructure for deploying applications. They offer services ranging from simple web hosting to complex machine learning platforms, allowing developers to focus on building applications rather than managing servers.\n\nInfrastructure as Code (IaC) tools like Terraform and CloudFormation let you define and manage infrastructure using code. This approach brings version control, testing, and automation to infrastructure management.\n\nMonitoring and logging tools help you understand how your applications behave in production. Tools like Prometheus, Grafana, and ELK stack (Elasticsearch, Logstash, Kibana) provide insights into application performance, errors, and user behavior.\n\nAPI development tools like Postman, Swagger, and GraphQL playgrounds help design, test, and document APIs. Well-designed APIs are crucial for building scalable, maintainable systems.' },
      { page: 27, text: 'Chapter 7: Security Best Practices\n\nSecurity should be considered throughout the software development lifecycle, not added as an afterthought. Understanding common vulnerabilities and how to prevent them is essential for every developer.\n\nThe OWASP Top 10 identifies the most critical web application security risks. These include injection attacks, broken authentication, sensitive data exposure, and security misconfigurations. Familiarizing yourself with these risks helps you write more secure code.\n\nInput validation is your first line of defense against many attacks. Never trust user input - always validate, sanitize, and escape data before processing it. Use parameterized queries to prevent SQL injection, and validate file uploads to prevent malicious code execution.\n\nAuthentication verifies user identity, while authorization determines what authenticated users can access. Implement strong password policies, use multi-factor authentication, and follow the principle of least privilege when granting permissions.' },
      { page: 28, text: 'Encryption protects sensitive data both at rest and in transit. Use established encryption libraries rather than implementing your own cryptographic functions. HTTPS should be mandatory for all web applications, and sensitive data should be encrypted in databases.\n\nRegular security updates are crucial for maintaining application security. Keep dependencies up to date, monitor security advisories, and have a plan for quickly patching critical vulnerabilities.\n\nSecure coding practices include avoiding hard-coded secrets, implementing proper error handling that doesn\'t leak sensitive information, and using security-focused code analysis tools.\n\nSecurity testing should be integrated into your development process. This includes both automated security scanning and manual penetration testing to identify vulnerabilities before they reach production.' },
      { page: 29, text: 'Chapter 8: Performance Optimization\n\nPerformance optimization involves making applications run faster and use resources more efficiently. Understanding common performance bottlenecks and optimization techniques is crucial for building scalable applications.\n\nProfiling helps identify performance bottlenecks by measuring where your application spends time and resources. Use profiling tools specific to your language and platform to identify hotspots that would benefit from optimization.\n\nAlgorithmic optimization often provides the biggest performance gains. Choosing the right algorithm or data structure can improve performance by orders of magnitude. Sometimes a simple change like using a hash table instead of a linear search can dramatically improve performance.\n\nCaching stores frequently accessed data in fast storage to avoid expensive recomputation or database queries. Implement caching at multiple levels: in-memory caches for frequently used data, database query caches, and content delivery networks (CDNs) for static assets.' },
      { page: 30, text: 'Database optimization is crucial for data-intensive applications. Proper indexing can dramatically improve query performance, but too many indices can slow down write operations. Understand your query patterns and index accordingly.\n\nCode-level optimizations include avoiding unnecessary object creation, using efficient string operations, and minimizing memory allocations. However, focus on algorithmic improvements first - micro-optimizations should come after profiling identifies specific bottlenecks.\n\nNetwork optimization reduces latency and bandwidth usage. Minimize HTTP requests, compress responses, use efficient data formats like JSON instead of XML, and implement proper caching headers.\n\nRemember that premature optimization is often counterproductive. Focus on writing clean, correct code first, then optimize based on actual performance measurements rather than assumptions.' },
      { page: 31, text: 'Chapter 9: Database Design and Management\n\nDatabase design is fundamental to building efficient, scalable applications. Understanding relational database concepts like normalization, indexing, and query optimization is essential for most developers.\n\nNormalization reduces data redundancy by organizing data into related tables. The first normal form eliminates repeating groups, second normal form removes partial dependencies, and third normal form eliminates transitive dependencies. While normalization reduces storage and maintains consistency, it can complicate queries.\n\nIndexes are data structures that improve query performance by providing fast access paths to data. B-tree indexes are most common and work well for range queries and sorting. Hash indexes provide fast equality lookups but don\'t support range queries.\n\nQuery optimization involves writing efficient SQL and understanding how the database executes queries. Use EXPLAIN plans to understand query execution, avoid unnecessary joins, and filter data as early as possible in your queries.' },
      { page: 32, text: 'NoSQL databases provide alternatives to traditional relational databases for specific use cases. Document databases like MongoDB store data as flexible documents, making them suitable for content management and catalogs. Key-value stores like Redis provide fast access to simple data structures. Column-family databases like Cassandra excel at handling large amounts of time-series data.\n\nDatabase transactions ensure data consistency through ACID properties: Atomicity (all operations succeed or fail together), Consistency (data remains valid), Isolation (concurrent transactions don\'t interfere), and Durability (committed changes persist).\n\nConnection pooling manages database connections efficiently by reusing connections across requests rather than creating new ones for each operation. This reduces overhead and improves application performance.\n\nDatabase migration tools help manage schema changes over time. They allow you to version your database schema and apply changes consistently across different environments.' },
      { page: 33, text: 'Chapter 10: Web Development Fundamentals\n\nWeb development involves creating applications that run in web browsers and communicate over the internet. Understanding HTTP, HTML, CSS, and JavaScript is fundamental to web development.\n\nHTTP is the protocol that browsers use to communicate with web servers. Understanding HTTP methods (GET, POST, PUT, DELETE), status codes, and headers is crucial for building web applications. RESTful APIs use HTTP conventions to create predictable, standardized interfaces.\n\nHTML structures web content using semantic elements like headers, paragraphs, lists, and links. Modern HTML5 provides rich elements for multimedia, forms, and interactive content. Semantic HTML improves accessibility and search engine optimization.\n\nCSS controls the visual presentation of web pages. Modern CSS includes powerful features like Flexbox and Grid for layout, animations and transitions for interactivity, and media queries for responsive design that adapts to different screen sizes.' },
      { page: 34, text: 'JavaScript adds interactivity to web pages and powers server-side applications through Node.js. Understanding JavaScript\'s unique features like prototypal inheritance, closures, and asynchronous programming is essential for effective web development.\n\nAsynchronous programming handles operations that take time to complete, like network requests or file operations. JavaScript uses callbacks, promises, and async/await to manage asynchronous code without blocking the user interface.\n\nWeb frameworks like React, Vue, and Angular provide structured approaches to building complex web applications. They handle common tasks like state management, routing, and component lifecycle, allowing developers to focus on application logic.\n\nWeb security is particularly important because web applications are exposed to the internet. Implement Content Security Policy, use HTTPS, sanitize user input, and protect against common attacks like cross-site scripting (XSS) and cross-site request forgery (CSRF).' },
      { page: 35, text: 'Chapter 11: Mobile Development\n\nMobile development creates applications for smartphones and tablets. You can build native apps using platform-specific languages (Swift for iOS, Kotlin for Android) or cross-platform apps using frameworks like React Native or Flutter.\n\nNative development provides the best performance and access to platform-specific features but requires maintaining separate codebases for each platform. iOS development uses Xcode and Swift (or Objective-C), while Android development uses Android Studio and Kotlin (or Java).\n\nCross-platform frameworks allow you to write code once and deploy to multiple platforms. React Native uses JavaScript and React concepts, while Flutter uses Dart and provides its own UI toolkit. These approaches reduce development time but may have performance trade-offs.\n\nMobile applications must consider limited resources like battery life, memory, and network connectivity. Implement efficient networking, optimize image loading, and design for offline functionality where appropriate.' },
      { page: 36, text: 'User interface design for mobile requires different considerations than desktop applications. Touch interfaces, smaller screens, and varying orientations all affect how users interact with your application.\n\nPush notifications keep users engaged with your application even when it\'s not actively being used. Implement notifications thoughtfully - too many notifications can lead users to disable them entirely.\n\nMobile app stores have specific requirements for app submission, including design guidelines, security requirements, and review processes. Understanding these requirements early helps ensure smooth app deployment.\n\nMobile analytics help you understand how users interact with your application. Track user flows, identify crash points, and measure feature usage to continuously improve your application.' },
      { page: 37, text: 'Chapter 12: Emerging Technologies\n\nArtificial Intelligence and Machine Learning are transforming how we build applications. Understanding basic ML concepts helps you leverage these technologies effectively, even if you don\'t become an ML specialist.\n\nMachine Learning enables computers to learn patterns from data without explicit programming. Supervised learning uses labeled training data to make predictions, unsupervised learning finds patterns in unlabeled data, and reinforcement learning optimizes actions through trial and error.\n\nCloud computing provides scalable, on-demand access to computing resources. Understanding cloud services helps you build applications that can scale globally without managing physical infrastructure.\n\nMicroservices architecture breaks applications into small, independent services that communicate over networks. This approach improves scalability and allows teams to work independently, but adds complexity in service coordination and monitoring.' },
      { page: 38, text: 'DevOps practices bridge the gap between development and operations teams. Continuous Integration/Continuous Deployment (CI/CD) pipelines automate testing and deployment, reducing manual errors and deployment time.\n\nBlockchain technology provides decentralized, tamper-resistant record keeping. While most famous for cryptocurrencies, blockchain has applications in supply chain tracking, digital identity, and smart contracts.\n\nInternet of Things (IoT) connects everyday devices to the internet, creating opportunities for smart homes, industrial automation, and environmental monitoring. IoT development often involves constrained devices with limited processing power and battery life.\n\nQuantum computing promises to solve certain problems exponentially faster than classical computers. While still emerging, understanding quantum concepts may become important for cryptography and optimization problems.' },
      ]
  },

  {
    id: 'free-5',
    title: 'Mindful Living',
    author: 'Dr. Maya Patel',
    category: 'Self-Help',
    description: 'Discover the power of mindfulness and how it can transform your daily life. Practical techniques for stress reduction and mental clarity.',
    isfeatured: true,
    is_free_to_read: true,
    content: [
      { page: 1, text: 'Chapter 1: What is Mindfulness?\n\nMindfulness is the practice of being present in the moment, aware of your thoughts and feelings without judgment. It\'s about observing your experience as it unfolds, rather than getting caught up in the stories your mind creates about that experience.\n\nThe roots of mindfulness can be traced back thousands of years to Buddhist meditation practices. However, in recent decades, scientific research has validated many of the benefits that practitioners have long known. Studies show that regular mindfulness practice can reduce stress, improve focus, enhance emotional regulation, and even boost immune function.\n\nAt its core, mindfulness is about waking up to your life. How often do we go through our days on autopilot, barely noticing what we\'re doing or how we\'re feeling? Mindfulness invites us to step out of this unconscious state and engage fully with our present moment experience.\n\nThe practice doesn\'t require any special equipment or beliefs. It\'s simply about paying attention in a particular way - with intention and without judgment.' },
      { page: 2, text: 'In our fast-paced world, mindfulness offers a refuge from stress and anxiety. It teaches us to respond rather than react to life\'s challenges. When we\'re mindful, we create a space between stimulus and response, allowing us to choose our actions more wisely.\n\nMany people think mindfulness means emptying the mind or stopping thoughts altogether. This is a common misconception. The mind\'s job is to think, and trying to stop thoughts is like trying to stop the ocean from having waves. Instead, mindfulness teaches us to observe our thoughts without getting swept away by them.\n\nImagine your thoughts as clouds passing through the sky of your awareness. Some clouds are light and fluffy (pleasant thoughts), others are dark and stormy (difficult thoughts). In mindfulness, you\'re the sky - vast, open, and unchanging - while the clouds are temporary visitors.\n\nThis perspective can be incredibly liberating. You begin to realize that you are not your thoughts, and that difficult emotions and sensations are temporary experiences rather than permanent fixtures of your identity.' },
      { page: 3, text: 'Chapter 2: Basic Breathing Techniques\n\nBreathing is the foundation of mindfulness practice. It\'s always available to us, and it connects the mind and body in a direct way. When we focus on our breath, we anchor ourselves in the present moment.\n\nThe breath is unique because it operates both automatically and under conscious control. This dual nature makes it an ideal bridge between the unconscious and conscious aspects of our experience.\n\nHere\'s a simple breathing exercise to get started:\n\n1. Find a comfortable sitting position with your back straight but not rigid\n2. Close your eyes or soften your gaze downward\n3. Bring your attention to your natural breath without trying to change it\n4. Notice the sensation of air entering and leaving your nostrils\n5. When your mind wanders (and it will), gently return your attention to the breath\n\nStart with just 5 minutes of this practice. As you become more comfortable, you can gradually increase the duration.' },
      { page: 4, text: 'Here\'s a more structured breathing technique called the 4-7-8 breath:\n\n1. Exhale completely through your mouth\n2. Close your mouth and inhale through your nose for 4 counts\n3. Hold your breath for 7 counts\n4. Exhale through your mouth for 8 counts\n5. Repeat this cycle 3-4 times\n\nThis technique is particularly helpful for reducing anxiety and promoting relaxation. The extended exhale activates the parasympathetic nervous system, which is responsible for the body\'s rest and digest response.\n\nAnother powerful technique is belly breathing or diaphragmatic breathing. Place one hand on your chest and another on your belly. As you breathe, try to keep the hand on your chest relatively still while the hand on your belly rises and falls. This type of breathing is more efficient and calming than shallow chest breathing.\n\nRemember, the goal isn\'t to breathe perfectly, but to use the breath as an anchor for your attention. Each time you notice your mind has wandered and you bring it back to the breath, you\'re strengthening your mindfulness muscle.' },
      { page: 5, text: 'Chapter 3: Daily Mindfulness Practices\n\nIncorporating mindfulness into your daily routine doesn\'t require hours of meditation. Small moments of awareness throughout the day can make a significant difference in your overall well-being and quality of life.\n\nMindful eating is one of the most accessible practices. The next time you eat, try to engage all your senses. Notice the colors, textures, and aromas of your food. Chew slowly and pay attention to the flavors. This not only enhances your enjoyment of the meal but can also improve digestion and help you recognize when you\'re full.\n\nWalking meditation is another excellent way to practice mindfulness. As you walk, focus on the sensation of your feet touching the ground. Notice the rhythm of your steps and the movement of your body through space. You can do this whether you\'re walking in nature or simply moving from one room to another.\n\nMindful listening can transform your relationships. When someone is speaking to you, try to give them your full attention. Notice any urge to interrupt or formulate your response while they\'re still talking. Simply listen with an open heart and mind.\n\nEven routine activities like washing dishes or brushing your teeth can become opportunities for mindfulness. Focus on the sensations, sounds, and movements involved in these activities rather than letting your mind wander to your to-do list.' }
    ]
  },
  {
    id: 'free-6',
    title: 'Climate Change Solutions',
    author: 'Prof. James Green',
    category: 'Science',
    description: 'An accessible guide to understanding climate change and the innovative solutions being developed to address this global challenge.',
    isfeatured: true,
    is_free_to_read: true,
    content: [
      { page: 1, text: 'Chapter 1: Understanding Climate Change\n\nClimate change refers to long-term shifts in global temperatures and weather patterns. While climate variations are natural, human activities have accelerated these changes dramatically since the Industrial Revolution began in the late 18th century.\n\nThe Earth\'s climate system is incredibly complex, involving interactions between the atmosphere, oceans, land surfaces, ice sheets, and living organisms. Small changes in one component can have cascading effects throughout the entire system.\n\nThe greenhouse effect is central to understanding climate change. Certain gases in our atmosphere trap heat from the sun, keeping our planet warm enough to support life. Without this natural greenhouse effect, Earth would be about 33°C colder and largely uninhabitable.\n\nHowever, human activities have significantly increased the concentration of greenhouse gases, intensifying this warming effect. Carbon dioxide levels have increased by over 40% since pre-industrial times, primarily due to burning fossil fuels, deforestation, and industrial processes.\n\nThe consequences of this enhanced greenhouse effect are already visible around the world: rising global temperatures, melting ice caps, rising sea levels, changing precipitation patterns, and more frequent extreme weather events.' },
      { page: 2, text: 'The primary cause of recent climate change is the increase in greenhouse gases in our atmosphere, particularly carbon dioxide from burning fossil fuels. Every year, human activities release over 40 billion tons of CO2 into the atmosphere.\n\nFossil fuels - coal, oil, and natural gas - are formed from ancient organic matter that stored carbon underground for millions of years. When we burn these fuels for energy, we rapidly release this stored carbon as CO2, disrupting the natural carbon cycle.\n\nDeforestation is another significant contributor. Forests act as carbon sinks, absorbing CO2 from the atmosphere during photosynthesis. When forests are cleared for agriculture or development, not only do we lose these carbon sinks, but the stored carbon in trees is also released back to the atmosphere.\n\nIndustrial processes, agriculture, and transportation all contribute to greenhouse gas emissions. Methane from livestock and rice cultivation, nitrous oxide from fertilizers, and fluorinated gases from refrigeration all add to the problem.\n\nThe warming we\'ve observed is unequivocal. The last decade included nine of the ten warmest years on record. Arctic sea ice is declining at a rate of about 13% per decade, and global sea levels have risen about 20 centimeters since 1900.' },
      { page: 3, text: 'Chapter 2: Renewable Energy Solutions\n\nRenewable energy sources like solar, wind, and hydroelectric power offer clean alternatives to fossil fuels. These technologies have advanced rapidly in recent years, becoming increasingly efficient and cost-effective.\n\nSolar photovoltaic (PV) technology converts sunlight directly into electricity using semiconductor materials. The cost of solar panels has dropped by over 90% in the past decade, making solar power competitive with fossil fuels in many regions. Large-scale solar farms can now generate electricity at costs below 3 cents per kilowatt-hour.\n\nWind energy harnesses the kinetic energy of moving air to generate electricity. Modern wind turbines are marvels of engineering, with rotors spanning over 150 meters and towers reaching heights of 100 meters or more. Offshore wind farms can access stronger, more consistent winds, further increasing efficiency.\n\nHydroelectric power has been used for over a century and remains the world\'s largest source of renewable electricity. Modern hydroelectric facilities range from massive dams to small run-of-river systems that have minimal environmental impact.\n\nGeothermal energy taps into the Earth\'s internal heat, providing both electricity generation and direct heating applications. Enhanced geothermal systems are expanding the potential for this technology to new regions.' },
      { page: 4, text: 'Solar energy has become increasingly affordable and efficient, making it the fastest-growing source of new electricity generation worldwide. In many regions, solar is now the cheapest source of electricity ever recorded.\n\nThe efficiency of solar panels continues to improve. While early commercial panels converted only about 6% of sunlight into electricity, modern panels routinely achieve efficiencies of 20-22%, with laboratory demonstrations exceeding 40% efficiency.\n\nEnergy storage is crucial for renewable energy systems because the sun doesn\'t always shine and the wind doesn\'t always blow. Battery technology, particularly lithium-ion batteries, has improved dramatically. Costs have fallen by nearly 90% over the past decade, making large-scale energy storage economically viable.\n\nSmart grids use digital technology to manage electricity distribution more efficiently. They can automatically balance supply and demand, integrate renewable energy sources, and even allow consumers to sell excess solar power back to the grid.\n\nElectric vehicles represent another crucial piece of the clean energy puzzle. As the transportation sector electrifies, the demand for clean electricity will grow, further driving renewable energy deployment. Vehicle batteries can also serve as distributed storage for the grid.' },
      { page: 5, text: 'Chapter 3: Individual Actions That Matter\n\nWhile systemic change is crucial for addressing climate change, individual actions also play an important role. Every person can contribute to climate solutions through their daily choices and by advocating for broader changes.\n\nEnergy use in homes and buildings accounts for a significant portion of greenhouse gas emissions. Simple actions like switching to LED light bulbs, improving insulation, and using programmable thermostats can reduce energy consumption by 20-30%. These measures often pay for themselves through energy savings.\n\nTransportation choices have a major impact on your carbon footprint. Walking, cycling, or using public transportation for short trips can significantly reduce emissions. When driving is necessary, fuel-efficient or electric vehicles make a substantial difference.\n\nDiet choices matter too. Animal agriculture, particularly beef production, generates significant greenhouse gas emissions. Reducing meat consumption, especially beef, can have a meaningful impact. You don\'t need to become vegetarian overnight - even one meat-free day per week makes a difference.\n\nConsumption patterns affect climate in multiple ways. Buying less stuff, choosing durable goods, and supporting companies with strong environmental commitments all help. The circular economy model - where products are designed for reuse and recycling - offers a path toward sustainable consumption.\n\nPerhaps most importantly, use your voice. Talk to friends and family about climate change, vote for leaders who prioritize climate action, and support organizations working on solutions. Individual actions multiply when they inspire others and drive systemic change.' }
    ]
  }
];

const convertToLocalBook = (book: any): Book => ({
  id: book.id,
  title: book.title,
  author: book.author,
  category: book.category,
  description: book.description,
  isfeatured: book.isfeatured,
  is_free_to_read: book.is_free_to_read,
  content: book.content?.map((page: any) => ({
    page: page.page || page.pageNumber || 1,
    text: page.text || page.content || ''
  }))
});

const allFreeBooks = [
  ...booksData.filter(book => book.is_free_to_read).map(convertToLocalBook), 
  ...additionalFreeBooks
];

export const FreeBooks = () => {
  const [selectedBook, setSelectedBook] = useState<Book | null>(null);
  const [isReaderOpen, setIsReaderOpen] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [categoryFilter, setCategoryFilter] = useState<string>('All');

  const openBookReader = (book: Book, fullscreen = false) => {
    setSelectedBook(book);
    setIsReaderOpen(true);
    setIsFullscreen(fullscreen);
  };

  const closeBookReader = () => {
    setIsReaderOpen(false);
    setSelectedBook(null);
    setIsFullscreen(false);
  };

  const freeCategories = ['All', ...Array.from(new Set(allFreeBooks.map(book => book.category)))];
  
  const filteredFreeBooks = categoryFilter === 'All' 
    ? allFreeBooks 
    : allFreeBooks.filter(book => book.category === categoryFilter);

  return (
    <div className="min-h-screen bg-background">
      {/* Header */}
      <header className="bg-primary text-primary-foreground py-8">
        <div className="container mx-auto px-4">
          <div className="text-center">
            <h1 className="text-4xl font-bold mb-2 flex items-center justify-center">
              <Library className="h-10 w-10 mr-3" />
              Free Books
            </h1>
            <p className="text-xl opacity-90">Read Amazing Books Completely Free</p>
            <p className="mt-2 opacity-75">Discover our collection of free books available for instant reading</p>
          </div>
        </div>
      </header>

      <div className="container mx-auto px-4 py-8">
        {/* Category Filters */}
        <div className="flex items-center justify-between mb-6">
          <h2 className="text-2xl font-semibold">Browse by Category</h2>
          <div className="flex gap-2">
            {freeCategories.map((category) => (
              <Button
                key={category}
                variant={categoryFilter === category ? "default" : "outline"}
                size="sm"
                onClick={() => setCategoryFilter(category)}
              >
                {category}
              </Button>
            ))}
          </div>
        </div>

        {/* Free Books Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {filteredFreeBooks.map((book) => (
            <Card key={book.id} className="hover:shadow-lg transition-shadow">
              <CardHeader>
                <div className="flex items-start justify-between">
                  <div className="flex-1">
                    <CardTitle className="text-lg mb-2">{book.title}</CardTitle>
                    <div className="flex items-center text-muted-foreground mb-2">
                      <User className="h-4 w-4 mr-1" />
                      <span className="text-sm">{book.author}</span>
                    </div>
                    <Badge variant="secondary" className="mb-2">
                      {book.category}
                    </Badge>
                  </div>
                  <Badge variant="outline" className="bg-green-50 text-green-700 border-green-200">
                    <BookOpen className="h-3 w-3 mr-1" />
                    Free
                  </Badge>
                </div>
              </CardHeader>
              <CardContent>
                <p className="text-muted-foreground text-sm mb-4 line-clamp-3">
                  {book.description}
                </p>
                <div className="flex items-center justify-between">
                  <span className="text-sm text-muted-foreground">
                    {book.content?.length || 0} pages
                  </span>
                  <div className="flex gap-2">
                    <Button 
                      size="sm"
                      onClick={() => openBookReader(book, false)}
                      className="bg-primary hover:bg-primary/90"
                    >
                      <BookOpen className="h-4 w-4 mr-2" />
                      Read
                    </Button>
                    <Button 
                      size="sm"
                      variant="outline"
                      onClick={() => openBookReader(book, true)}
                    >
                      <Maximize className="h-4 w-4 mr-2" />
                      Fullscreen
                    </Button>
                  </div>
                </div>
              </CardContent>
            </Card>
          ))}
        </div>

        {filteredFreeBooks.length === 0 && (
          <div className="text-center py-12">
            <Library className="h-16 w-16 mx-auto text-muted-foreground mb-4" />
            <h3 className="text-xl font-semibold mb-2">No books found</h3>
            <p className="text-muted-foreground">
              Try adjusting your category filter to find more books.
            </p>
          </div>
        )}
      </div>

      {/* Book Reader Modal */}
      {selectedBook && (
        <BookReader
          book={selectedBook}
          isOpen={isReaderOpen}
          onClose={closeBookReader}
          fullscreen={isFullscreen}
        />
      )}
    </div>
  );
};
// BookBridge update
